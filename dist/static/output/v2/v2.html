
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px;">
          <ul><li>CI CD<ul><li onclick="location.href='../CI CD/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../CI CD/构建优化.html';">构建优化</li></ul></li><li onclick="location.href='../FromBD.html';">FromBD</li><li onclick="location.href='../Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li>archive<ul></ul></li><li>cs<ul><li>android<ul><li onclick="location.href='../cs/android/holder.html';">holder</li></ul></li><li>llvm<ul><li onclick="location.href='../cs/llvm/holder.html';">holder</li></ul></li><li>project<ul><li onclick="location.href='../cs/project/holder.html';">holder</li></ul></li><li>system<ul><li onclick="location.href='../cs/system/holder.html';">holder</li></ul></li></ul></li><li>java jvm android<ul><li onclick="location.href='../java jvm android/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../java jvm android/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../java jvm android/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../java jvm android/Glide理解.html';">Glide理解</li><li onclick="location.href='../java jvm android/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../java jvm android/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../java jvm android/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../java jvm android/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../java jvm android/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../java jvm android/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../java jvm android/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../java jvm android/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../java jvm android/React理解.html';">React理解</li><li onclick="location.href='../java jvm android/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../java jvm android/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../java jvm android/volatile理解.html';">volatile理解</li><li onclick="location.href='../java jvm android/手写React Native.html';">手写React Native</li><li onclick="location.href='../java jvm android/插件化方案理解.html';">插件化方案理解</li><li onclick="location.href='../java jvm android/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../java jvm android/第三方面试整理.html';">第三方面试整理</li></ul></li><li>jt<ul></ul></li><li>kotlin<ul><li onclick="location.href='../kotlin/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li>META-INF<ul></ul></li></ul></li><li onclick="location.href='../siteCol.html';">siteCol</li><li>thought works<ul><li onclick="location.href='../thought works/Thought Works.html';">Thought Works</li></ul></li><li>tool<ul></ul></li><li>v2<ul><li onclick="location.href='../v2/offer checker.html';">offer checker</li><li>pics<ul></ul></li><li onclick="location.href='../v2/v2.html';">v2</li></ul></li><li onclick="location.href='../事件流.html';">事件流</li><li>图说<ul></ul></li><li onclick="location.href='../年终总结.html';">年终总结</li><li>思考与心态<ul><li onclick="location.href='../思考与心态/2020-11.html';">2020-11</li><li>Plans<ul></ul></li><li onclick="location.href='../思考与心态/生活探索.html';">生活探索</li><li onclick="location.href='../思考与心态/还能做点什么.html';">还能做点什么</li></ul></li><li>操作系统<ul><li onclick="location.href='../操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li>测试<ul><li onclick="location.href='../测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li>算法<ul><li onclick="location.href='../算法/算法整理.html';">算法整理</li></ul></li><li>网络<ul><li onclick="location.href='../网络/计算机网络.html';">计算机网络</li></ul></li><li>职场见解<ul><li onclick="location.href='../职场见解/ 外部风险管理.html';"> 外部风险管理</li><li>@bd<ul><li onclick="location.href='../职场见解/@bd/小程序学习与理解.html';">小程序学习与理解</li><li onclick="location.href='../职场见解/@bd/感受与反思.html';">感受与反思</li></ul></li><li onclick="location.href='../职场见解/专注过程与专注结果.html';">专注过程与专注结果</li><li onclick="location.href='../职场见解/为什么研发的话语权这么低.html';">为什么研发的话语权这么低</li><li onclick="location.href='../职场见解/风险管理与开发流程.html';">风险管理与开发流程</li></ul></li><li onclick="location.href='../补码运算.html';">补码运算</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-activity" class="anchor" href="#activity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>activity</h1>
<h2>
<a id="user-content-mvc-mvp-mvvm" class="anchor" href="#mvc-mvp-mvvm" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>mvc, mvp, mvvm</h2>
<p>首先，不使用这些框架，一般会遇到难以维护、难以拓展、难以测试的问题</p>
<p><a href="https://camo.githubusercontent.com/6f2d3213b9a5b97436e1ea1358c2ab4c3c16ddeafd1b2358ae08fcca895d2d5e/687474703a2f2f7777772e6469676967656e652e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30352f636f6d706172652d4d56564d4d56504d56432d31303234783831342e6a706567" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/6f2d3213b9a5b97436e1ea1358c2ab4c3c16ddeafd1b2358ae08fcca895d2d5e/687474703a2f2f7777772e6469676967656e652e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031382f30352f636f6d706172652d4d56564d4d56504d56432d31303234783831342e6a706567" alt="mvvm" data-canonical-src="http://www.digigene.com/wp-content/uploads/2018/05/compare-MVVMMVPMVC-1024x814.jpeg" style="max-width:100%;"></a></p>
<p>MVC</p>
<p>View提供基本功能接口，UI事件由View感知，调用controller响应并由controller找Model获取数据。model获取数据之后告知controller（可能不是通过回调而是接口），controller以view接口来停止loading，并告知view。<strong>view再自行从model中读数据结果</strong>。（所以这设计很脑残，大部分场景不合适，3个角色关系有点复杂）</p>
<p>MVP</p>
<p>View提供基本接口，UI事件由View感知，调用presenter响应并由presenter找model获取数据，数据获取通过回调，而非presenter接口。之后再通过View接口完成UI更新和操作。在这个过程中，<strong>View不需要感知model，不需要操作model。但是presenter和View还存在双向的关系</strong>。</p>
<p>MVVM</p>
<p>在presenter的基础上，view和ViewModel不再双向关联。ViewModel只需要提供数据订阅。而View根据ui事件自行通过viewModel接口调用去请求新数据，而数据的更新一般通过ViewModel提供的数据订阅完成。</p>
<p>这后面两种的可测试性都要好很多。
实际的View一般是activity或者Fragment，也可以是ViewGroup自定义。</p>
<h2>
<a id="user-content-activity生命周期细节" class="anchor" href="#activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BB%86%E8%8A%82" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>activity生命周期细节</h2>
<p>activity A -&gt; activity B
activity A的stop一定是在activity B的resume之后。至于为什么，可以思考下动画，动动脑子也想得通。</p>
<p><a href="pics/activity-onStop.png" target="_blank" rel="noopener noreferrer"><img src="pics/activity-onStop.png" alt="onStop" style="max-width:100%;"></a></p>
<h2>
<a id="user-content-activity-启动" class="anchor" href="#activity-%E5%90%AF%E5%8A%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>activity 启动</h2>
<p><a href="https://medium.com/android-news/android-application-launch-explained-from-zygote-to-your-activity-oncreate-8a8f036864b" rel="nofollow">https://medium.com/android-news/android-application-launch-explained-from-zygote-to-your-activity-oncreate-8a8f036864b</a></p>
<h2>
<a id="user-content-第一次activity的渲染时机" class="anchor" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1activity%E7%9A%84%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>第一次activity的渲染时机</h2>
<p>也就是在activityThread#handleResumeActivity的时候，</p>
<p>windowManagerImpl.addView</p>
<pre><code>scheduleTraversals:1946, ViewRootImpl (android.view)
requestLayout:1632, ViewRootImpl (android.view)
setView:981, ViewRootImpl (android.view)
addView:399, WindowManagerGlobal (android.view)
addView:95, WindowManagerImpl (android.view)
handleResumeActivity:4638, ActivityThread (android.app)
execute:52, ResumeActivityItem (android.app.servertransaction)
executeLifecycleState:181, TransactionExecutor (android.app.servertransaction)
execute:102, TransactionExecutor (android.app.servertransaction)
handleMessage:2239, ActivityThread$H (android.app)
dispatchMessage:107, Handler (android.os)
loop:237, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
</code></pre>
<h2>
<a id="user-content-draw调用栈" class="anchor" href="#draw%E8%B0%83%E7%94%A8%E6%A0%88" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>draw调用栈</h2>
<pre><code>onDraw:43, MainActivity$TestView (org.tu.android)
draw:21813, View (android.view)
updateDisplayListIfDirty:20642, View (android.view)
draw:21525, View (android.view)
drawChild:4542, ViewGroup (android.view)
dispatchDraw:4279, ViewGroup (android.view)
draw:21820, View (android.view)
draw:869, DecorView (com.android.internal.policy)
updateDisplayListIfDirty:20642, View (android.view)
updateViewTreeDisplayList:575, ThreadedRenderer (android.view)
updateRootDisplayList:581, ThreadedRenderer (android.view)
draw:654, ThreadedRenderer (android.view)
draw:4129, ViewRootImpl (android.view)
performDraw:3917, ViewRootImpl (android.view)
performTraversals:3223, ViewRootImpl (android.view)
doTraversal:2054, ViewRootImpl (android.view)
run:8459, ViewRootImpl$TraversalRunnable (android.view)
run:1065, Choreographer$CallbackRecord (android.view)
doCallbacks:889, Choreographer (android.view)
doFrame:816, Choreographer (android.view)
run:1050, Choreographer$FrameDisplayEventReceiver (android.view)
handleCallback:883, Handler (android.os)
dispatchMessage:100, Handler (android.os)
loop:237, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
</code></pre>
<p>threadedRendererupdateRootDisplayList</p>
<h2>
<a id="user-content-choreographer-渲染时机" class="anchor" href="#choreographer-%E6%B8%B2%E6%9F%93%E6%97%B6%E6%9C%BA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>choreographer 渲染时机</h2>
<p>scheduleVsync(native)(from any choreographer.postCallback call. eg: ViewRootImpl#scheduleTraversals)</p>
<p>dispatchVsync(from native, activity thread, message queue, next.)</p>
<pre><code>onVsync:1042, Choreographer$FrameDisplayEventReceiver (android.view)
dispatchVsync:187, DisplayEventReceiver (android.view)
nativePollOnce:-1, MessageQueue (android.os)
next:336, MessageQueue (android.os)
loop:184, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
</code></pre>
<p>choreographer#onVsync-&gt; FrameHandler.message(计算时间延迟)-&gt;FrameDisplayEventReceiver#onRun-&gt;doFrame</p>
<p>note:</p>
<p>ActivityThread的looper也就是mainLooper是会被多个handler所使用的哦。也就是尽管都复用着一个messageQueue，但是message的target不同（handler不同）。</p>
<p>几个常见的Handler:</p>
<ul>
<li>ActivityThread#H 用于处理多个Activity生命周期、application周期相关事情</li>
<li>Choregrapher#FrameHandler 用于scheduleVsync, doFrame</li>
</ul>
<h2>
<a id="user-content-综上渲染概述" class="anchor" href="#%E7%BB%BC%E4%B8%8A%E6%B8%B2%E6%9F%93%E6%A6%82%E8%BF%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>综上渲染概述</h2>
<ul>
<li>
<p>context.getSystemService是来获取当前进程的系统服务“客户端”，一般是xxServiceImpl，而系统服务的“服务端”是在他们自己的进程之中，一般是“xxManagerService”，客户端和服务端通信一般使用binder机制，transact-&gt;onTransact-&gt;服务端方法实现</p>
</li>
<li>
<p>对于activity也好，dialog也好，或者是类似悬浮窗这种需要在window添加自定义view的，本质上都是<code>windowManagerService#addView(View, WParam)</code>，这个View对于activity和dialog来说都是decorView，对于自定义浮窗来说就是自己的view。</p>
<ul>
<li>
<p>在<code>wm#addView</code>这个方法里，会通过进程内的单例WindowManagerGlobal来完成具体实现。主要包括创建ViewRootImpl, WParam准备，然后记录到list(View), list(ViewRootImpl), list(WParam)。最后会调用ViewRootImpl#setView.  也就是说，无论是activity, dialog还是自己的view，其实在wm的Add过程中都会被创建一个ViewRootImpl，不过对于activity来说，是在handleResumeActivity的时候。并且会记录只需要创建一次，只有在handleDestroyActivity的时候才调用wm#removeView与之对应。而非pause的时候。</p>
</li>
<li>
<p>在ViewRootImpl#setView的时候，会处理很多事情，包括requestLayout、准备事件分发stage。而<code>requestLayout-&gt;scheduleTranversals-&gt;Choreographer.postCallback-&gt;Choreographer#scheduleVsync</code>，等待下一个Choreographer的<code>dispatchVsync（会由主线程的looper的messageQueue的next的native来触发回调）-&gt; Choreographer#doFrame-&gt;...-&gt;ViewRootImpl#performTraversals</code>(scheduleTraversals方法用到了MessageQueue异步message, 发送了同步栅栏，而在doTraversals的时候删除了栅栏)</p>
</li>
<li>
<p>在ViewRootImpl#performTraversals的时候，会进行view的measure, layout, draw。draw的时候，硬件绘制会去ThreadedRenderer来进行，其过程包括，ThreadedRenderer#updateRootDisplayList、syncAndDrawFrame(native)，如其所述，先更新displayList，再做nativeSync。软绘的时候是surface的lockCanvas来进行，见ViewRootImpl#drawSoftware。</p>
<ul>
<li>displayList其实顾名思义，就是为了在硬绘时记录绘制指令。这块的canvas是通过RenderNode#beginRecording来获得的RecordingCanvas(extends DisplayListCanvas).</li>
<li>无论是软绘，还是硬绘，这里所述其实都是基于canvas的api的绘制。</li>
<li>ViewRootImpl的surface从哪里来？threadedRenderer从哪里来？这些都来自于在ViewRootImpl的构造过程，即WindowManagerGlobal#addView. 在viewRootImpl的构造函数里，会有</li>
</ul>
<div class="highlight highlight-source-java"><pre>mAttachInfo <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">View</span>.<span class="pl-smi">AttachInfo</span>(mWindowSession, mWindow, display, <span class="pl-c1">this</span>, mHandler, <span class="pl-c1">this</span>,context);</pre></div>
<p>以及如果发现开启了硬件加速的时候</p>
<div class="highlight highlight-source-java"><pre>mAttachInfo<span class="pl-k">.</span>mThreadedRenderer <span class="pl-k">=</span> <span class="pl-smi">ThreadedRenderer</span><span class="pl-k">.</span>create(mContext, translucent,attrs<span class="pl-k">.</span>getTitle()<span class="pl-k">.</span>toString());</pre></div>
<p>这里会直接走到它的构造方法ThreadedRenderer: HardwareRenderer，搬运一下注释：</p>
<blockquote>
<p>创建硬件加速渲染器的实例。 这用于将从RenderNode构建的场景渲染到输出Surface 。 可以根据需要有任意数量的HardwareRenderer实例。
资源和生命周期
所有HardwareRenderer实例共享一个公共的渲染线程。 渲染线程包含执行GPU加速渲染所需的GPU上下文和资源。 这样，创建的第一个HardwareRenderer带有创建关联的GPU上下文的成本，但是此后每个增量的HardwareRenderer都相当便宜。 预期的用法是为每个活动的Surface都有一个HardwareRenderer实例。 例如，当“活动”显示“对话框”时，系统内部将使用2个硬件渲染器，这两个渲染器可能同时绘制。
注意：由于渲染线程具有共享，协作的性质，因此至关重要的是，所使用的任何Surface必须具有迅速，可靠的使用方。 系统提供的使用者，例如android.view.SurfaceView ，android.view.Window.takeSurface(SurfaceHolder.Callback2)或android.view.TextureView均符合此要求。 但是，如果使用自定义使用者（例如在使用SurfaceTexture或android.media.ImageReader ，则应用程序有责任确保他们迅速，迅速地使用更新。 否则，将导致渲染线程停滞在该表面上，从而阻塞所有HardwareRenderer实例</p>
</blockquote>
</li>
<li>
<p>所以PhoneWindow又是有何用？关于window的注释：</p>
<blockquote>
<p>顶级窗口外观和行为策略的抽象基类。 此类的实例应用作添加到窗口管理器的顶级视图。 它提供了标准的UI策略，例如背景，标题区域，默认键处理等。
此抽象类的唯一现有实现是android.view.PhoneWindow，您需要在需要Window时实例化该实例</p>
</blockquote>
<p>思考下我们平时开发中，关于phoneWindow的使用也主要是，<code>activity#getWindow#getDecorView</code>, 或者<code>activity#getWindow#getAttributes#....</code>因此，很容易看出来，PhoneWindow其实主要是用于管理View结构和窗口的一些属性的(标题、背景色、action_bar..)。</p>
</li>
</ul>
</li>
<li>
<p>ActivityThread负责了不止一个activity的生命周期，而是所有此进程的activity。application的生命周期也是由它来负责，先bind application,再会有activity的transaction item，见<code>ActivityLifecycleItem</code>包括<code>StartActivityItem</code>, <code>ResumeActivityItem</code>，实际实现还是在activityThread。目前没有关于<code>applicationThread</code>的东西。</p>
</li>
</ul>
<h1>
<a id="user-content-surface-flinger" class="anchor" href="#surface-flinger" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>surface flinger</h1>
<p>doComposition -&gt; doComposeSurfaces</p>
<p><a href="https://skytoby.github.io/2020/Android%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6-SurfaceFlinger%E5%8E%9F%E7%90%86/" rel="nofollow">https://skytoby.github.io/2020/Android%E5%88%B7%E6%96%B0%E6%9C%BA%E5%88%B6-SurfaceFlinger%E5%8E%9F%E7%90%86/</a></p>
<p><a href="https://betterprogramming.pub/android-internals-for-rendering-a-view-430cd394e225" rel="nofollow">https://betterprogramming.pub/android-internals-for-rendering-a-view-430cd394e225</a></p>
<h2>
<a id="user-content-surfaceview" class="anchor" href="#surfaceview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SurfaceView</h2>
<p>独立线程渲染，有自己的surface。</p>
<h2>
<a id="user-content-eglsurfaceviewglthread-频率控制" class="anchor" href="#eglsurfaceviewglthread-%E9%A2%91%E7%8E%87%E6%8E%A7%E5%88%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>eglSurfaceView#GLThread 频率控制</h2>
<p>其实是egl#eglSwapBuffer的过程。对于GLSurfaceView，是会通过swapBuffersWithDamageKHR-&gt;surface#dequeueBuffer-&gt;IGraphicsBufferQueue#dequeueBuffer-&gt;跨进程（估计是到surfaceFlinger），这个过程中，surfaceFlinger决定的等待。</p>
<p>而TextureView的egl.eglSwapBuffer频率并不受控制，可能是因为在eglSwapBuffer所传入的eglSurface不同决定的。</p>
<p>profiler图片可以看pics文件夹。</p>
<h2>
<a id="user-content-surface" class="anchor" href="#surface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>surface</h2>
<p>在surfaceFlinger对应的是layer，拥有bufferQueue。Surface是bufferQueue的生产者，SurfaceFlinger是消费者。</p>
<h2>
<a id="user-content-事件分发" class="anchor" href="#%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>事件分发</h2>
<p>调用栈</p>
<pre><code>dispatchTouchEvent:53, MainActivity$TestView (org.tu.android)
dispatchTransformedTouchEvent:3131, ViewGroup (android.view)
dispatchTouchEvent:2731, ViewGroup (android.view)
dispatchTransformedTouchEvent:3131, ViewGroup (android.view)
dispatchTouchEvent:2731, ViewGroup (android.view)
superDispatchTouchEvent:528, DecorView (com.android.internal.policy)
superDispatchTouchEvent:1857, PhoneWindow (com.android.internal.policy)
dispatchTouchEvent:4105, Activity (android.app)
dispatchTouchEvent:69, WindowCallbackWrapper (androidx.appcompat.view)
dispatchTouchEvent:478, DecorView (com.android.internal.policy)
dispatchPointerEvent:13887, View (android.view)
processPointerEvent:6209, ViewRootImpl$ViewPostImeInputStage (android.view)
onProcess:5947, ViewRootImpl$ViewPostImeInputStage (android.view)
deliver:5400, ViewRootImpl$InputStage (android.view)
onDeliverToNext:5460, ViewRootImpl$InputStage (android.view)
forward:5419, ViewRootImpl$InputStage (android.view)
forward:5584, ViewRootImpl$AsyncInputStage (android.view)
apply:5427, ViewRootImpl$InputStage (android.view)
apply:5641, ViewRootImpl$AsyncInputStage (android.view)
deliver:5400, ViewRootImpl$InputStage (android.view)
onDeliverToNext:5460, ViewRootImpl$InputStage (android.view)
forward:5419, ViewRootImpl$InputStage (android.view)
apply:5427, ViewRootImpl$InputStage (android.view)
deliver:5400, ViewRootImpl$InputStage (android.view)
deliverInputEvent:8356, ViewRootImpl (android.view)
doProcessInputEvents:8325, ViewRootImpl (android.view)
enqueueInputEvent:8276, ViewRootImpl (android.view)
onInputEvent:8495, ViewRootImpl$WindowInputEventReceiver (android.view)
dispatchInputEvent:188, InputEventReceiver (android.view)
nativePollOnce:-1, MessageQueue (android.os)
next:336, MessageQueue (android.os)
loop:184, Looper (android.os)
main:7830, ActivityThread (android.app)
invoke:-1, Method (java.lang.reflect)
run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os)
main:1040, ZygoteInit (com.android.internal.os)
</code></pre>
<h2>
<a id="user-content-性能优化" class="anchor" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>性能优化</h2>
<p>速度</p>
<ul>
<li>预加载</li>
<li>懒加载</li>
<li>预连接，节点选优</li>
<li>AsyncInflate, viewStub,</li>
<li>代码细节，log toString</li>
<li>优先级队列</li>
</ul>
<p>内存</p>
<ul>
<li>线程管理</li>
<li>内存泄漏</li>
</ul>
<p>包大小</p>
<ul>
<li>混淆</li>
<li>插件、异步下发</li>
<li>矢量</li>
</ul>
<p>设备</p>
<ul>
<li>设备估分，动画相关</li>
<li>lite版本</li>
</ul>
<h2>
<a id="user-content-网络" class="anchor" href="#%E7%BD%91%E7%BB%9C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>网络</h2>
<h2>
<a id="user-content-activity-manager-service" class="anchor" href="#activity-manager-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Activity manager service</h2>
<p>启动activity, 查进程，查acitivity信息</p>
<h2>
<a id="user-content-window-manager-service" class="anchor" href="#window-manager-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Window manager service</h2>
<h2>
<a id="user-content-package-manager-service" class="anchor" href="#package-manager-service" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Package manager service</h2>
<h2>
<a id="user-content-window-viewrootimpl-decorview" class="anchor" href="#window-viewrootimpl-decorview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>window, viewRootImpl, decorView</h2>
<ul>
<li>Activity {window, decorView}</li>
<li>DecorView {viewRootImpl}</li>
<li>WindowManagerGlobal {list(decorView), list(ViewRootImpl)}</li>
<li>Window {DecorView}</li>
<li>ViewRootImpl {mWindow: W: IWindow.Stub}</li>
</ul>
<h2>
<a id="user-content-加固" class="anchor" href="#%E5%8A%A0%E5%9B%BA" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>加固</h2>
<p>类加载字节数组加密解密</p>
<h2>
<a id="user-content-包签名验证" class="anchor" href="#%E5%8C%85%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>包签名验证</h2>
<h1>
<a id="user-content-网络-1" class="anchor" href="#%E7%BD%91%E7%BB%9C-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>网络</h1>
<h2>
<a id="user-content-抓包原理" class="anchor" href="#%E6%8A%93%E5%8C%85%E5%8E%9F%E7%90%86" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>抓包原理</h2>
<h2>
<a id="user-content-http2-feature" class="anchor" href="#http2-feature" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>http2 feature</h2>
<p>http:1,1.1,2...<a href="https://www.ruanyifeng.com/blog/2016/08/http.html" rel="nofollow">https://www.ruanyifeng.com/blog/2016/08/http.html</a></p>
<h2>
<a id="user-content-dns" class="anchor" href="#dns" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>dns</h2>
<p>check google cloud desc: <a href="https://cloud.google.com/dns/docs/dns-overview?hl=zh-cn" rel="nofollow">https://cloud.google.com/dns/docs/dns-overview?hl=zh-cn</a></p>
<p>dns server发现</p>
<p>dns request协议</p>
<p>look like:<a href="https://serverfault.com/questions/173187/what-does-a-dns-request-look-like" rel="nofollow">https://serverfault.com/questions/173187/what-does-a-dns-request-look-like</a></p>
<p>dns 返回</p>
<p>优先查看缓存，每个记录(record)都会有time-to-live表示有效时间。若无对应的记录，或缓存失效，则继续向上一级dns服务询问。</p>
<p>dns server分级</p>
<ul>
<li>本地dns server(local)</li>
<li>根 dns server(.root是根域名，固定)</li>
<li>顶级域名 dns server(.org, .com是顶级域名)</li>
<li>次级域名 dns server(xxx.com中的xxx)</li>
<li>三级域名 dns server(mail.xxx.com中的mail)</li>
</ul>
<p>查询以“分而治之”的思想进行查询。即根-&gt;顶级域名-&gt;...，使用udp协议，因为tcp的数据包需要9个（7个握手挥手，1个Request，1个Response）</p>
<p>用户—本地递归服务器—根权威服务器—COM权威服务器—xxorg.com权威服务器</p>
<h2>
<a id="user-content-http-dns" class="anchor" href="#http-dns" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>http dns</h2>
<p>传统dns会有几个安全风险，一个是传输过程不加密，中间路由可以收集个人信息。一个是，解析器不一定可靠，解析器一般是系统提供的，而系统的解析器一般又是连接到网络时，路由来提供的，不可靠的解析器可以篡改结果。</p>
<p><a href="https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/" rel="nofollow">https://hacks.mozilla.org/2018/05/a-cartoon-intro-to-dns-over-https/</a></p>
<p>而解决方式是，更改可靠的解析器，此外，解析器的dns请求是以解析器供应商的ip发起，规避个人信息泄漏。此外客户到解析器的dns请求是以https传输。</p>
<h2>
<a id="user-content-udp" class="anchor" href="#udp" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>udp</h2>
<h1>
<a id="user-content-java" class="anchor" href="#java" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>java</h1>
<h3>
<a id="user-content-不变-逆变-协变httpszhwikipediaorgwikie58d8fe58f98e4b88ee98086e58f98" class="anchor" href="#%E4%B8%8D%E5%8F%98-%E9%80%86%E5%8F%98-%E5%8D%8F%E5%8F%98httpszhwikipediaorgwikie58d8fe58f98e4b88ee98086e58f98" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>不变 逆变 协变（<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%EF%BC%89" rel="nofollow">https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98）</a>
</h3>
<p><code>&lt;T&gt;</code> 不变</p>
<p><code>&lt;? extend SomeSuperClass&gt;</code> 协变</p>
<p><code>&lt;? super SomeChildClass&gt;</code> 逆变</p>
<h2>
<a id="user-content-构造过程" class="anchor" href="#%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>构造过程</h2>
<p>注意初始化代码块会按前后顺序插入在构造函数super后的第一句话。而不是构造结束后。</p>
<h2>
<a id="user-content-类加载" class="anchor" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>类加载</h2>
<p>加载（classLoader) 链接{验证，准备，解析（jvm中符号引用改为内存引用)} 初始化</p>
<p>class loader 并不能直接替换java核心类。核心类的classpath是通过bootclasspath传入，但是在安卓上，应用进程都是fork出来的，无法更改这些dvm的初始参数。(link)[<a href="https://stackoverflow.com/questions/39713958/is-it-possible-to-prepend-bootclasspath-for-dalvik-vm-on-android" rel="nofollow">https://stackoverflow.com/questions/39713958/is-it-possible-to-prepend-bootclasspath-for-dalvik-vm-on-android</a>]</p>
<p><a href="https://zhuanlan.zhihu.com/p/33509426" rel="nofollow">https://zhuanlan.zhihu.com/p/33509426</a></p>
<p><a href="https://camo.githubusercontent.com/220b59c1c5eedce122daed2d5cf35fc5da6e1b58e8a6b43c7737d4c81fd49836/68747470733a2f2f7374617469632e6a61766174706f696e742e636f6d2f636f72652f696d616765732f636c6173736c6f616465722d696e2d6a6176612e706e67" target="_blank" rel="nofollow"><img src="https://camo.githubusercontent.com/220b59c1c5eedce122daed2d5cf35fc5da6e1b58e8a6b43c7737d4c81fd49836/68747470733a2f2f7374617469632e6a61766174706f696e742e636f6d2f636f72652f696d616765732f636c6173736c6f616465722d696e2d6a6176612e706e67" alt="classLoader层级" data-canonical-src="https://static.javatpoint.com/core/images/classloader-in-java.png" style="max-width:100%;"></a></p>
<h1>
<a id="user-content-算法" class="anchor" href="#%E7%AE%97%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>算法</h1>
<h3>
<a id="user-content-逆序链表求和" class="anchor" href="#%E9%80%86%E5%BA%8F%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>逆序链表求和</h3>
<ul>
<li>注意判空</li>
<li>注意最后的进位，可能需要创建新的节点</li>
<li>注意返回.next</li>
<li>注意返回结果的顺序</li>
</ul>
<h3>
<a id="user-content-每一个数字右侧第一个大于自己的数字" class="anchor" href="#%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E5%8F%B3%E4%BE%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E5%AD%97" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>每一个数字右侧第一个大于自己的数字</h3>
<ul>
<li>栈记录索引</li>
<li>遍历的时候若小于栈顶索引的元素，则入栈，若大于，则出栈并对结果数组中这个位置赋值。</li>
</ul>
<h3>
<a id="user-content-顺时针遍历二维数组" class="anchor" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>顺时针遍历二维数组</h3>
<ul>
<li>注意判空</li>
<li>注意退出条件</li>
</ul>
<h2>
<a id="user-content-链表每k个节点倒序" class="anchor" href="#%E9%93%BE%E8%A1%A8%E6%AF%8Fk%E4%B8%AA%E8%8A%82%E7%82%B9%E5%80%92%E5%BA%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>链表每k个节点倒序。</h2>
<ul>
<li>链表reverse作为方法</li>
<li>计数，&gt;=k的时候end.next =null摘取一块链表，然后reverse，再拼接回去。</li>
</ul>
<h2>
<a id="user-content-example-project" class="anchor" href="#example-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>example project</h2>
<ul>
<li>camera</li>
<li>openGl</li>
<li>mvc, mvp, mvvm</li>
<li>dokka plugin</li>
</ul>
<h2>
<a id="user-content-线程和进程" class="anchor" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>线程和进程</h2>
<p>线程是cpu最小的调度单位，进程是系统的最小资源分配单位。
注意理解系统的线程和jvm的线程。java里的线程实际上的实现取决于jvm，但一般jvm实现的时候都会将其映射到系统提供的线程能力上。以获得更好的cpu利用。</p>
<p>另外，jvm上除了java我们创建的线程，还会有jvm自己的一些线程。甚至包括debugger</p>
<h2>
<a id="user-content-wait-notify-notifyall" class="anchor" href="#wait-notify-notifyall" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>wait, notify, notifyall</h2>
<p>一定要先持有这个对象的锁，然后才可以调用这些方法。也就是一定要在<code>synchronized</code>此对象中调用。并且需要等notify的线程退出自己的<code>synchronized</code>块。</p>
<p><code>wait</code>会释放掉<code>synchronized</code>持有的锁。<code>synchronized</code>是可以重入的。</p>
<h2>
<a id="user-content-reentrantlock-reentrantreadwritelock-countdownlatch" class="anchor" href="#reentrantlock-reentrantreadwritelock-countdownlatch" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ReentrantLock, ReentrantReadWriteLock, CountDownLatch</h2>
<p>都是基于AQS。AQS是通过int来维护状态的同步器基类，支持两种方式工作（但一般只选择一种，独占模式、共享模式），独占模式是state=0表示空闲，占有的时候一般会+1，共享模式是state&gt;0表示空闲，占有的时候通过-acquire。上述的这些<code>ReentrantLock</code>, <code>ReentrantReadWriteLock</code>都包含了公平、非公平的实现，每个实现各自都是<code>aqs</code>的具体子类。</p>
<p>公平和非公平的实现差异主要在于：</p>
<ul>
<li>非公平，在<code>tryAcquire</code>的时候，检查state空闲，就会acquire(即compareAndSetState)。</li>
<li>公平，在<code>tryAcquire</code>的时候，检查state空闲，如果自己的线程不是在等待队列的head的话，会返回false。如果等待队列为空的话，则也会尝试acquire。或者自己已经是占有线程了直接acquire。</li>
</ul>
<p>此外，<code>synchronized</code>也是可以重入的。
read more(<a href="https://juejin.cn/post/6844903997438951437#heading-23" rel="nofollow">https://juejin.cn/post/6844903997438951437#heading-23</a>)</p>
<h2>
<a id="user-content-学java并发" class="anchor" href="#%E5%AD%A6java%E5%B9%B6%E5%8F%91" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>学java并发</h2>
<p><a href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html" rel="nofollow">http://tutorials.jenkov.com/java-concurrency/thread-signaling.html</a></p>
<h2>
<a id="user-content-thread-local" class="anchor" href="#thread-local" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>thread local</h2>
<ul>
<li>thead{threadLocalMap}</li>
<li>ThreadLocalMap(ThreadLocal -&gt; Object)</li>
<li>looper(sLooper(mainLooper), sThreadLocal = ThreadLocal()(用于myLooper的返回（即当前线程的looper）-&gt;sThreadLocal.get()-&gt; Thread.threadLocalMap.get(sThreadLocal)-&gt;object)</li>
</ul>
<h2>
<a id="user-content-startservice-bindservice" class="anchor" href="#startservice-bindservice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>startService, bindService</h2>
<p>当需要和service通信的时候，使用bind，如果只是单纯启动，使用start.</p>
<h2>
<a id="user-content-tcp拥塞" class="anchor" href="#tcp%E6%8B%A5%E5%A1%9E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>tcp拥塞</h2>
<p>会有一个发送窗口，一个拥塞的阈值sstresh，当发送窗口小于sstresh的时候，是指数增。大于sstresh的时候改为线性增。（慢开始）</p>
<p>当出现收不到ack（超时），则sstresh为当前发送窗口的一半取值。重新开始进行上述慢开始的过程。</p>
<p>当出现重复确认的时候，会进行“快速恢复”，即在sstresh减半的情况下，直接把发送窗口设置为sstresh，进行线性增加。</p>
<h2>
<a id="user-content-4种引用" class="anchor" href="#4%E7%A7%8D%E5%BC%95%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>4种引用</h2>
<p>强引用 -&gt; 软引用（内存不足时回收） -&gt; 弱引用（gc回收） -&gt; 虚引用（形同虚设，随时可能回收）
后三种都可以结合referenceQueue跟踪回收状态。</p>
<h2>
<a id="user-content-handler-message-async" class="anchor" href="#handler-message-async" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>handler message async</h2>
<p>async 和 sync的message只有这个boolean的差异。其具体作用依赖于MesssageQueue#PostSyncBarrier。这个方法实际上是插入一个message，target为空（message.target为空也就这一种情况）。在MessageQueue#next方法里，如果发现了target=null的message，则会认为是遇到了“同步栅栏”即syncBarrier，会遍历链表找到async为true的message来处理。而不再处理同步消息。直到MessageQueue#removeSyncBarrier发生。</p>
<p>![handler message async](./pics/v2/pics/handler message async.png)
<a href="https://www.cnblogs.com/angeldevil/p/3340644.html" rel="nofollow">https://www.cnblogs.com/angeldevil/p/3340644.html</a></p>
<h1>
<a id="user-content-opengl" class="anchor" href="#opengl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>openGl</h1>
<p><a href="https://learnopengl.com/Introduction" rel="nofollow">https://learnopengl.com/Introduction</a></p>

          </div>
      </div>
  </body>
  
  </html>
    