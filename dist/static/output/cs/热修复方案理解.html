
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px; flex-shrink:0;">
          <ul><li onclick="location.href='../cs/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../cs/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../cs/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../cs/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../cs/Glide理解.html';">Glide理解</li><li onclick="location.href='../cs/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../cs/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../cs/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../cs/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../cs/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../cs/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li onclick="location.href='../cs/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../cs/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../cs/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../cs/React理解.html';">React理解</li><li onclick="location.href='../cs/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../cs/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../cs/binder ipc原理.html';">binder ipc原理</li><li onclick="location.href='../cs/index.html';">index</li><li onclick="location.href='../cs/knowledge tree.html';">knowledge tree</li><li>pics<ul></ul></li><li onclick="location.href='../cs/v2.html';">v2</li><li onclick="location.href='../cs/volatile理解.html';">volatile理解</li><li onclick="location.href='../cs/手写React Native.html';">手写React Native</li><li onclick="location.href='../cs/插件化方案理解.html';">插件化方案理解</li><li>操作系统<ul><li onclick="location.href='../cs/操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li onclick="location.href='../cs/构建优化.html';">构建优化</li><li>测试<ul><li onclick="location.href='../cs/测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../cs/测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li onclick="location.href='../cs/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../cs/第三方面试整理.html';">第三方面试整理</li><li onclick="location.href='../cs/算法整理.html';">算法整理</li><li onclick="location.href='../cs/补码运算.html';">补码运算</li><li onclick="location.href='../cs/计算机网络.html';">计算机网络</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-热修复方案理解" class="anchor" href="#%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88%E7%90%86%E8%A7%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>热修复方案理解</h1>
<p>热修复指的是在不发版的前提下修复代码问题。注意，Android上无法实现类卸载。但在Android 8已经可以重新加载类了。详见<a href="https://juejin.im/post/5ce2c40d6fb9a07ec754ee13" rel="nofollow">Android Studio Apply Changes</a></p>
<ul>
<li>热启动热Java层修复</li>
<li>热启动底层替换修复</li>
<li>冷启动热修复</li>
<li>资源热修复</li>
</ul>
<h2>
<a id="user-content-热启动修复" class="anchor" href="#%E7%83%AD%E5%90%AF%E5%8A%A8%E4%BF%AE%E5%A4%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>热启动修复</h2>
<h3>
<a id="user-content-java层热启动修复" class="anchor" href="#java%E5%B1%82%E7%83%AD%E5%90%AF%E5%8A%A8%E4%BF%AE%E5%A4%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Java层热启动修复</h3>
<p>提前在修复点打桩，根据后台下发修复情况，下载不同的远程dex等文件，下载完成后即可加载，变更前端逻辑。加载调用协议需要提前规定设计。</p>
<h3>
<a id="user-content-底层热启动修复" class="anchor" href="#%E5%BA%95%E5%B1%82%E7%83%AD%E5%90%AF%E5%8A%A8%E4%BF%AE%E5%A4%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>底层热启动修复</h3>
<p>以art虚拟机为例，依靠jni，通过更改artMethod信息，即代码的访问权限、执行地址等，使得在不破坏原有代码方法调用上，使用了新的方法实现等。</p>
<ul>
<li>Andfix使用此方案</li>
<li>如果厂家定制了不同的art实现，那么此方案会出现兼容性问题</li>
<li>实际上有一些后来的Hook方案，不依赖类似Xposed框架，其实现原理也是如此，通过jni对artMethod进行修改，在hook点上调用了自己的Hook方法。</li>
</ul>
<h2>
<a id="user-content-冷启动热修复" class="anchor" href="#%E5%86%B7%E5%90%AF%E5%8A%A8%E7%83%AD%E4%BF%AE%E5%A4%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>冷启动热修复</h2>
<ul>
<li>也可以同前面第一个方案，下载远程的dex文件后，在下次启动时加载。</li>
<li>修复方案提供差量dex文件，修复方案通过将其与当前的dex合并，之后在下次启动时即可加载了新的dex文件。</li>
</ul>
<h2>
<a id="user-content-资源热修复" class="anchor" href="#%E8%B5%84%E6%BA%90%E7%83%AD%E4%BF%AE%E5%A4%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>资源热修复</h2>
<p>可参见插件化方案理解中的资源插件方案。</p>
<h2>
<a id="user-content-instantrun-vs-apply-changes" class="anchor" href="#instantrun-vs-apply-changes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>InstantRun vs Apply Changes</h2>
<p><a href="https://juejin.im/entry/5731f50ef38c840067dcce48" rel="nofollow">InstantRun理解</a></p>
<p>增加gradle transform task，对所有类、application做转化。每个类都增加了一个IncrementalChanges成员变量，每个类的方法都会检查这个成员变量，若不为空，则调用它的access$dispatch方法，参数1是方法签名string，参数2是参数列表数组。application启动时同时启动local socket和android studio通信，以此获取changes list。获取后，如果是热更新（android studio负责记录分析哪些代码发生变化，做增量编译，以及控制更新模式），那么app server 通过socket获取到变更后，加载该类（一般补丁类的名称是原类的名称+$override。这里考虑如果多次补丁，那么为了让其能加载新的同名类，实际上每次加载的时候都需要生成新的classloader加载（因为不同的classloader加载的类被认为不同，而在转化过的application中，也对classloader包装了一层，添加了一层委托，在这层中从而来控制overide的类加载问题。这里有很多classloader上要注意的技巧）。最终对目标类的IncrementalChanges成员变量赋值。这个主要是hot swap的情况。</p>
<p>其他的warm swap，cold swap类似。可以查看原文。</p>
<p><a href="https://juejin.im/post/5ce2c40d6fb9a07ec754ee13" rel="nofollow">Apply Changes理解</a></p>
<p>借助安卓8类重新加载+数据库dex类缓存校验apk差异类+delta push</p>

          </div>
      </div>
  </body>
  
  </html>
    