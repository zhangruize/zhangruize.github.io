
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px; flex-shrink:0;">
          <ul><li onclick="location.href='../cs/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../cs/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../cs/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../cs/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../cs/Glide理解.html';">Glide理解</li><li onclick="location.href='../cs/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../cs/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../cs/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../cs/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../cs/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../cs/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li onclick="location.href='../cs/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../cs/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../cs/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../cs/React理解.html';">React理解</li><li onclick="location.href='../cs/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../cs/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../cs/binder ipc原理.html';">binder ipc原理</li><li onclick="location.href='../cs/index.html';">index</li><li onclick="location.href='../cs/knowledge tree.html';">knowledge tree</li><li>pics<ul></ul></li><li onclick="location.href='../cs/v2.html';">v2</li><li onclick="location.href='../cs/volatile理解.html';">volatile理解</li><li onclick="location.href='../cs/手写React Native.html';">手写React Native</li><li onclick="location.href='../cs/插件化方案理解.html';">插件化方案理解</li><li>操作系统<ul><li onclick="location.href='../cs/操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li onclick="location.href='../cs/构建优化.html';">构建优化</li><li>测试<ul><li onclick="location.href='../cs/测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../cs/测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li onclick="location.href='../cs/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../cs/第三方面试整理.html';">第三方面试整理</li><li onclick="location.href='../cs/算法整理.html';">算法整理</li><li onclick="location.href='../cs/补码运算.html';">补码运算</li><li onclick="location.href='../cs/计算机网络.html';">计算机网络</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-手写rn" class="anchor" href="#%E6%89%8B%E5%86%99rn" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>手写RN</h1>
<h2>
<a id="user-content-js引擎" class="anchor" href="#js%E5%BC%95%E6%93%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JS引擎</h2>
<p>在Android上可用的Js引擎（<a href="https://stackoverflow.com/questions/8374016/how-to-execute-javascript-on-android" rel="nofollow">讨论页面</a>）有如下这些：</p>
<ul>
<li>JSCore(JSC)（关于JSC和WebKit和Chromium等有很多关联，具体的参考后期补充）。</li>
<li>WebView</li>
<li>Rhino</li>
<li>V8</li>
</ul>
<p>而V8对于Java层需要JNI才能使用，有一个封装库叫<a href="https://github.com/eclipsesource/j2v8">J2V8</a>，选择使用了这个。仓库应该是在JCenter。最新可用需要查看这个<a href="https://github.com/eclipsesource/J2V8/issues/384">issue</a>。</p>
<h2>
<a id="user-content-hello-world" class="anchor" href="#hello-world" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hello, World</h2>
<p>万事皆从Hello, world开始。</p>
<h2>
<a id="user-content-草稿内容" class="anchor" href="#%E8%8D%89%E7%A8%BF%E5%86%85%E5%AE%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>草稿内容</h2>
<p>我们目标是把如下的JSX以原生的形式生成出来。后期会再考虑更复杂的View以及事件处理等，以及视图的更新。</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">&lt;</span><span class="pl-ent">App</span><span class="pl-c1">/</span><span class="pl-c1">&gt;</span>

<span class="pl-c1">--</span><span class="pl-c1">&gt;</span>

<span class="pl-c1">&lt;</span><span class="pl-ent">Text</span><span class="pl-c1">&gt;</span>Hello, <span class="pl-kos">{</span><span class="pl-s1">props</span><span class="pl-kos">.</span><span class="pl-c1">name</span><span class="pl-kos">}</span><span class="pl-c1">&lt;</span><span class="pl-c1">/</span><span class="pl-ent">Text</span><span class="pl-c1">&gt;</span></pre></div>
<p>未来甚至会考虑Java和Js的互通调用。比如借助Java触发网络请求等</p>
<p>因为这里会涉及过多JS语言要写的基础库，比如借助Babel把JSX转化为普通的JS函数调用等，我们先进一步把问题转化为如下的形式：</p>
<div class="highlight highlight-source-js"><pre>
<span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
    <span class="pl-k">return</span> <span class="pl-en">createElement</span><span class="pl-kos">(</span><span class="pl-s">"App"</span><span class="pl-kos">)</span>
<span class="pl-kos">}</span>

<span class="pl-k">class</span> <span class="pl-v">App</span> <span class="pl-k">extends</span> <span class="pl-v">RNElement</span><span class="pl-kos">{</span>
    <span class="pl-en">render</span><span class="pl-kos">(</span><span class="pl-kos">)</span><span class="pl-kos">{</span>
        <span class="pl-k">return</span> <span class="pl-en">createElement</span><span class="pl-kos">(</span><span class="pl-s">"Text"</span><span class="pl-kos">,</span>
            <span class="pl-kos">{</span>
                <span class="pl-c1">children</span>:<span class="pl-s1">props</span><span class="pl-kos">.</span><span class="pl-c1">name</span>
            <span class="pl-kos">}</span><span class="pl-kos">)</span>
    <span class="pl-kos">}</span>
<span class="pl-kos">}</span>

<span class="pl-c">//Text extends RNElement and it's a build-in element </span></pre></div>
<p>下面的问题，我们需要分层次进行考虑。</p>
<ul>
<li>对于UI前端逻辑，即上面的最顶端的应用层，是使用JS所写。并且会最终转化为若干的JS函数调用。</li>
<li>当JS层从应用层代码走向了JS的库层时，这些元素创建API的调用需要考虑该如何将信息进一步处理或者传递给其他层：
<ul>
<li>本层直接处理。那么JS库层第一步会形成一棵渲染的树。这棵树应是必须要生成的，至少是因为为了便于后面快速更新子节点。但也可以进一步转化为图形层的合成结果，甚至更进一步，直接转化为了图形API的调用清单。<strong>但是</strong>仔细思考一下，以React Native的角度来想，React只需要负责描述前端的样式，无论业务逻辑怎样，都会返回正确的视图样式，最后需要传递给不同平台的Native视图组件，最终的渲染流程也应该交给原生的视图系统，他们各自的算法去合成。而自己不需要过多干涉。我们暂且不深入讨论这种方式的利弊。但值得一提的是，<strong>这里显然会有另一种方式</strong>，就是如果JS层继续更进一步，把图形的合成也完成，最终转化为了图形系统的API调用。很明显的区别在于，前者（RN）对平台的要求是需要提供对应的原生组件，以及原生组件能够在原生系统上合成显示。后者方案对平台的要求是，支持图形API的直接使用（如OpenGL, EGL等）。其实后者的方案会更像<strong>Flutter</strong>的运作方式。</li>
<li>传递给其他层处理。是的，其实这两点我们不做严格区分。或者目前文档的区分不够明确，传递给其他层处理也可以是JS的更深层，或者内置的C层或者Java层。内置的C层是指伴随JS引擎（一般是C/C++）一块包含的C/C++库，用于处理这些视图的数据。而使用内置的C层的一个<strong>优点</strong>是，可以减少针对跨平台所需要写的代码量。C层可以更大程度直接复用一些统一的数据处理。</li>
</ul>
</li>
</ul>
<p>上面，我们讨论了从React转到最终如何以Native的形式呈现进行了一番深度的探讨。虽然直接转化到图形api的调用看起来已经不太像Native的含义，但也算方案的各种可能性。</p>
<p>下面我们将选择一种方式进行实现。</p>
<p>由于没有很好的C的水平，也对V8拓展不够熟悉，所以这里暂时不考虑从C/C++层拓展库的功能（处理视图数据等）。后面仅仅是JS &lt;--&gt; Java之间的使用。</p>
<p>因为考虑到，比如每一个<code>createElement</code>最终都会转化到Java库层的API上，比如我们把<code>Text</code>元素对应到了Android的<code>TextView</code>上，又把很多其他JSX元素对应到各种Android原生的组件上，当我们想把自定义的Element也和不同平台对应起来时，这里实际上就需要各平台端的自定义模块/组件注册绑定功能。依靠这种思维，前面的这种JSX-&gt;Android的对应关系，实际上也都属于各个平台的拓展，只是这些算是内置的，属于我们库在各个平台上本应该提供的基本模块/组件。</p>
<p>所以，我们下面实际要思考的是React层和各个平台层的拓展、注册、绑定这种关系。那么我们来初步思考下，各个平台需要提供的模块应需要实现怎样的接口呢？</p>
<p>Module:</p>
<ul>
<li>module name(id/key的作用)</li>
</ul>
<p>UiElementModule extends Module:</p>
<ul>
<li>
<p>boolean matchTargetTag(Element e) //返回是否是目标的JSX的Tag</p>
</li>
<li>
<p>onUpdate()</p>
</li>
</ul>
<p>Java库层提供的API：</p>
<ul>
<li>registerUiElementModule()</li>
<li>registerModule()  //一般需要等待Js主动调用</li>
</ul>
<p>/////2019 11 18</p>
<p>原生Module是什么，实际上是两类东西：</p>
<ol>
<li>可以在JSX使用的Tag。</li>
<li>可以在JS代码调用的方法。</li>
</ol>
<p>实际上两者对于原生Java而言没有区别</p>

          </div>
      </div>
  </body>
  
  </html>
    