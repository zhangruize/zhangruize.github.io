
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px; flex-shrink:0;">
          <ul><li onclick="location.href='../cs/0依赖创造一个语言跑起来.html';">0依赖创造一个语言跑起来</li><li onclick="location.href='../cs/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../cs/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../cs/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../cs/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../cs/Glide理解.html';">Glide理解</li><li onclick="location.href='../cs/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../cs/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../cs/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../cs/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../cs/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../cs/Js dev.html';">Js dev</li><li onclick="location.href='../cs/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li onclick="location.href='../cs/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../cs/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../cs/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../cs/React理解.html';">React理解</li><li onclick="location.href='../cs/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../cs/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../cs/binder ipc原理.html';">binder ipc原理</li><li onclick="location.href='../cs/dagger2.html';">dagger2</li><li onclick="location.href='../cs/index.html';">index</li><li onclick="location.href='../cs/js engines.html';">js engines</li><li onclick="location.href='../cs/knowledge tree.html';">knowledge tree</li><li>pics<ul></ul></li><li onclick="location.href='../cs/rust.html';">rust</li><li onclick="location.href='../cs/v2.html';">v2</li><li onclick="location.href='../cs/volatile理解.html';">volatile理解</li><li onclick="location.href='../cs/吉他指型推导.html';">吉他指型推导</li><li onclick="location.href='../cs/手写React Native.html';">手写React Native</li><li onclick="location.href='../cs/插件化方案理解.html';">插件化方案理解</li><li>操作系统<ul><li onclick="location.href='../cs/操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li onclick="location.href='../cs/构建优化.html';">构建优化</li><li>测试<ul><li onclick="location.href='../cs/测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../cs/测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li onclick="location.href='../cs/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../cs/第三方面试整理.html';">第三方面试整理</li><li onclick="location.href='../cs/算法整理.html';">算法整理</li><li onclick="location.href='../cs/补码运算.html';">补码运算</li><li onclick="location.href='../cs/计算机网络.html';">计算机网络</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-rxjava" class="anchor" href="#rxjava" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>RxJava</h1>
<h2>
<a id="user-content-pull-vs-push" class="anchor" href="#pull-vs-push" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>pull vs push</h2>
<p>有这么一种比较小众的说法，但或许有一定道理，“RxJava体现出来的Pull和Push”的区别？这个初听起来无法理解，但可以参考一个<a href="https://www.uwanttolearn.com/android/pull-vs-push-imperative-vs-reactive-reactive-programming-android-rxjava2-hell-part2/" rel="nofollow">文章</a>。在这个文章里，首先pull本身是指自己（观测者）去主动请求数据，push则是指（被观测者）数据变更时主动去通知观测者。pull如果想得到新的数据，往往需要poll，即不断去轮询，而push如果想得到新的数据，往往需要callback即可。而RxJava便是这样的工具，可以大量减少Callback这样的样板代码。而对应Android方面，这里更多的场景便是指网络请求或者页面事件等。</p>
<h2>
<a id="user-content-subscribeon-vs-observeon" class="anchor" href="#subscribeon-vs-observeon" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>subscribeOn vs observeOn</h2>
<p>关于RxJava，想到的一些特点是，链式调用，以及很多清晰、易用的基本原语、术语、操作符。onNext, onError, onComplete, Schedulers, Single, Flowable, map, flatMap等等。好用的同时，有时候会引入令人混淆的东西，比如observeOn以及subscribeOn，以及两者多次穿插会发生什么。</p>
<p>subscribeOn，即在哪里订阅，订阅完就该产生数据了，指的是被观测者在onSubscribe时候触发的线程环境。它的本质是生成一个新的被观测者，新生成的被观测者在onSubscribe即被订阅的时候，使用Schedulers里安排的线程上，触发自己本身的原始onSubscribe内容。</p>
<p>observeOn，即在哪里观测，指的是观测者被回调时期望的线程环境。它的本质是生成一个新的被观测者，新生成的被观测者在onSubscribe即被订阅的时候，会订阅原被观测者，此时的观测者是自身（即新生成的被观测者），在新生成的被观测者onNext,onError, onComplete时候，会使用Schedulers提供的线程，切换环境后调用后面观测者的onNext, onError, onComplete等。</p>
<p>思考下复杂场景，X.subscribeOn(A).observeOn(B).subscribe(O)。注意最后.subscribe(O)把观测者O传递给了上面倒数第二步生成的被观测者。而这个观测者根据上面所述，会进而继续调用前面的被观测者，即observeOn所生成的。而observeOn所生成的被观测者会准备在A线程环境中进而调用X从而产生数据。在产生完数据后，会回到subscribeOn所生成的被观测者，此时它的观测者是自己，在onNext又切换了线程最后在线程B中把数据交付给了O。</p>
<p>X.subscribeOn(A).observeOn(B).subscribeOn(C).subscribe(O)
可以试着分析一下，X应该会在A线程被调用，O应该会在B中调用</p>
<p>一个比较好的解释此方面的<a href="https://blog.csdn.net/michael1112/article/details/78688099" rel="nofollow">文章</a></p>
<h2>
<a id="user-content-链式调用" class="anchor" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>链式调用</h2>
<p>关于RxJava的链式调用，也远比看上去的更有意思。这里的链式调用虽然方法按顺序不断从上到下进行调用，但实际上每个方法都只是在进行包装，而最终只有subscribeXxx才会触发完整的封装链条调用。而且根据封装内容，最终封装后的产物在调用时是有一种从下到上的感觉。</p>

          </div>
      </div>
  </body>
  
  </html>
    