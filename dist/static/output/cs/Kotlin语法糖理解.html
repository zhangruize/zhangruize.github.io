
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px; flex-shrink:0;">
          <ul><li onclick="location.href='../cs/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../cs/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../cs/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../cs/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../cs/Glide理解.html';">Glide理解</li><li onclick="location.href='../cs/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../cs/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../cs/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../cs/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../cs/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../cs/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li onclick="location.href='../cs/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../cs/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../cs/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../cs/React理解.html';">React理解</li><li onclick="location.href='../cs/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../cs/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../cs/binder ipc原理.html';">binder ipc原理</li><li onclick="location.href='../cs/index.html';">index</li><li onclick="location.href='../cs/knowledge tree.html';">knowledge tree</li><li>pics<ul></ul></li><li onclick="location.href='../cs/v2.html';">v2</li><li onclick="location.href='../cs/volatile理解.html';">volatile理解</li><li onclick="location.href='../cs/手写React Native.html';">手写React Native</li><li onclick="location.href='../cs/插件化方案理解.html';">插件化方案理解</li><li>操作系统<ul><li onclick="location.href='../cs/操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li onclick="location.href='../cs/构建优化.html';">构建优化</li><li>测试<ul><li onclick="location.href='../cs/测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../cs/测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li onclick="location.href='../cs/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../cs/第三方面试整理.html';">第三方面试整理</li><li onclick="location.href='../cs/算法整理.html';">算法整理</li><li onclick="location.href='../cs/补码运算.html';">补码运算</li><li onclick="location.href='../cs/计算机网络.html';">计算机网络</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-kotlin语法糖理解" class="anchor" href="#kotlin%E8%AF%AD%E6%B3%95%E7%B3%96%E7%90%86%E8%A7%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Kotlin语法糖理解</h1>
<p>这里主要讲解Kotlin转为字节码的时候，尤其和Java相比，是如何实现它的一些语法特性的。</p>
<h2>
<a id="user-content-不需要类可以像函数式脚本一样运行" class="anchor" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B1%BB%E5%8F%AF%E4%BB%A5%E5%83%8F%E5%87%BD%E6%95%B0%E5%BC%8F%E8%84%9A%E6%9C%AC%E4%B8%80%E6%A0%B7%E8%BF%90%E8%A1%8C" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>不需要类，可以像函数式、脚本一样运行</h2>
<p>编译器自动按文件名生成了对应的class名的外层包装（final修饰）。定义的函数都会转为static的调用。由于有main作为主函数入口，所以实际上会类似Java的static void main入口。</p>
<h2>
<a id="user-content-参数默认值可选入参命名入参" class="anchor" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%AF%E9%80%89%E5%85%A5%E5%8F%82%E5%91%BD%E5%90%8D%E5%85%A5%E5%8F%82" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>参数默认值，可选入参，命名入参</h2>
<p>这些特性算是在一个方案里实现的。无论一个方法有多少参数的默认值（此时已经成为可选入参，以及支持命名入参），都会在我们定义之外再自动生成一个方法。这个方法相比于普通的定义，多了一个int和object的入参。object的入参含义暂且没发现。但int是借助位来标识有哪些有效入参，因此若发现无效入参，则可以对其赋值为默认值。见下面的例子：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-c"><span class="pl-c">//</span>方法原型</span>
test(p1<span class="pl-k">:</span><span class="pl-smi">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>def1<span class="pl-pds">"</span></span>, p2<span class="pl-k">:</span><span class="pl-smi">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>def2<span class="pl-pds">"</span></span>, p3<span class="pl-k">:</span><span class="pl-smi">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>def3<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">//</span>自动生成</span>
test(p1, p2, p3, <span class="pl-k">int</span>, object)
<span class="pl-c"><span class="pl-c">//</span>int从右到左，每一位都标识了第几个参数是否有效，1标识是有效入参，0标识无效入参，要使用默认值。</span>
<span class="pl-c"><span class="pl-c">//</span>最后为p1,p2,p3完成初始赋值后，调用真正的函数原型test(p1,p2,p3)</span></pre></div>

          </div>
      </div>
  </body>
  
  </html>
    