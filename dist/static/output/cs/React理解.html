
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px; flex-shrink:0;">
          <ul><li onclick="location.href='../cs/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../cs/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../cs/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../cs/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../cs/Glide理解.html';">Glide理解</li><li onclick="location.href='../cs/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../cs/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../cs/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../cs/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../cs/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../cs/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li onclick="location.href='../cs/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../cs/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../cs/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../cs/React理解.html';">React理解</li><li onclick="location.href='../cs/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../cs/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../cs/binder ipc原理.html';">binder ipc原理</li><li onclick="location.href='../cs/knowledge tree.html';">knowledge tree</li><li>pics<ul></ul></li><li onclick="location.href='../cs/v2.html';">v2</li><li onclick="location.href='../cs/volatile理解.html';">volatile理解</li><li onclick="location.href='../cs/手写React Native.html';">手写React Native</li><li onclick="location.href='../cs/插件化方案理解.html';">插件化方案理解</li><li>操作系统<ul><li onclick="location.href='../cs/操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li onclick="location.href='../cs/构建优化.html';">构建优化</li><li>测试<ul><li onclick="location.href='../cs/测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../cs/测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li onclick="location.href='../cs/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../cs/第三方面试整理.html';">第三方面试整理</li><li onclick="location.href='../cs/算法整理.html';">算法整理</li><li onclick="location.href='../cs/补码运算.html';">补码运算</li><li onclick="location.href='../cs/计算机网络.html';">计算机网络</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-react玩一玩" class="anchor" href="#react%E7%8E%A9%E4%B8%80%E7%8E%A9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>React玩一玩</h1>
<p>注意，此文说的是React而非React Native，RN方面的请见另外的文章。这里只是Web端所用的React。</p>
<h2>
<a id="user-content-声明式-vs-命令式" class="anchor" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F-vs-%E5%91%BD%E4%BB%A4%E5%BC%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>声明式 vs 命令式</h2>
<p>如果稍微接触下React，肯定会感受到JSX的精妙。它就像把Android Data Binding中xml的玩法直接嵌入到了业务代码之中。</p>
<p>声明式的表现是，只需要表达想要什么，对应的数据传入是什么即可。</p>
<p>命令式的表现是，你要一步一步思考如何把数据对应的内容绘制出来。</p>
<p>区别更深一步来讲，声明式的特点在于，你不需要考虑UI变更时要处理的各种细节，而只需要考虑在不同的数据、状态输入下，该返回怎样的视图即可（而不需要考虑视图该如何从上次状态切换到现在应该展示的状态）。至于视图状态切换的工作，则是React内部要完成的主要工作之一，而且是他们认为可以被解耦出来的部分（我觉得很有道理）。</p>
<h2>
<a id="user-content-视图更新算法" class="anchor" href="#%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%E7%AE%97%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>视图更新算法</h2>
<p>正如上面所说，React有一个很核心的思想是解耦出视图切换时的工作，让开发者只需要关注数据输入所对应的视图结果即可。那么这里势必要有很核心的关于视图切换的算法。<a href="https://zh-hans.reactjs.org/docs/reconciliation.html" rel="nofollow">官方介绍文档</a>。</p>
<h3>
<a id="user-content-树-还是-链表" class="anchor" href="#%E6%A0%91-%E8%BF%98%E6%98%AF-%E9%93%BE%E8%A1%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>树 还是 链表</h3>
<p>说到UI元素，其实在不同的层面角度上，所用的数据结构并不相同。对于应用层，我们更适合用树的结构来描述页面的UI元素。而对于系统的图形角度来说，会用到很多队列、链表这种线性结构。后者在看待视图时，各个应用的视图已经被对应的图形引擎整合完成，在系统角度看要渲染的更像是一套图层的列表，比如先渲染壁纸图层、应用图层、状态栏图层、导航栏图层等等。在这里显然已经不是树的结构所擅长的了。</p>
<p>回到React的应用层面上，其diffing算法核心要处理的场景就是树结构的更新。大体上而言如下：</p>
<ul>
<li>根节点类型不同时，重新渲染</li>
<li>根节点类型相同时，更新属性</li>
</ul>
<p>之后便是对子树进行类似递归。此外还有关于列表元素的处理，对每个列表元素的key进行判断，key是用于区分是否可以复用或者保留的标志。</p>
<h2>
<a id="user-content-jsx" class="anchor" href="#jsx" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>JSX</h2>
<p>JSX在React是很大的亮点之一。通过配套的工具，React使用<a href="https://babeljs.io/docs/en/" rel="nofollow">Babel</a>把JSX语法写出来的片段，最终编译为可以向低版本JS兼容的函数调用。这就好比我们在JS的基础上，又定制了一颗很大的语法糖，这个巧妙的语法糖把声明式的UI发挥到了极致。而Babel则是最终把这颗糖消化掉的核心。如果再调查一下，会看到Babel实际上是为了新规范JS向前兼容的编译器。除了React，还有更棒的产品如TypeScript等已经在用了。我们可以看到这些JS的“变种”最终是如何在Babel编译器下还原成最普通的JS脚本的。</p>
<p>在发布、部署应用的时候，只需要借助Babel即可生成最终的生产代码。至于Babel是否有开发、生产模式之分，我不确定，但感觉可以有。</p>
<h2>
<a id="user-content-pwa" class="anchor" href="#pwa" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>PWA</h2>
<p>React好像对PWA也支持友好。</p>

          </div>
      </div>
  </body>
  
  </html>
    