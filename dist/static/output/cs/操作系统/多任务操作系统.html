
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px; flex-shrink:0;">
          <ul><li onclick="location.href='../../cs/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../../cs/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../../cs/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../../cs/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../../cs/Glide理解.html';">Glide理解</li><li onclick="location.href='../../cs/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../../cs/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../../cs/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../../cs/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../../cs/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../../cs/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li onclick="location.href='../../cs/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../../cs/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../../cs/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../../cs/React理解.html';">React理解</li><li onclick="location.href='../../cs/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../../cs/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../../cs/binder ipc原理.html';">binder ipc原理</li><li onclick="location.href='../../cs/knowledge tree.html';">knowledge tree</li><li>pics<ul></ul></li><li onclick="location.href='../../cs/v2.html';">v2</li><li onclick="location.href='../../cs/volatile理解.html';">volatile理解</li><li onclick="location.href='../../cs/手写React Native.html';">手写React Native</li><li onclick="location.href='../../cs/插件化方案理解.html';">插件化方案理解</li><li>操作系统<ul><li onclick="location.href='../../cs/操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li onclick="location.href='../../cs/构建优化.html';">构建优化</li><li>测试<ul><li onclick="location.href='../../cs/测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../../cs/测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li onclick="location.href='../../cs/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../../cs/第三方面试整理.html';">第三方面试整理</li><li onclick="location.href='../../cs/算法整理.html';">算法整理</li><li onclick="location.href='../../cs/补码运算.html';">补码运算</li><li onclick="location.href='../../cs/计算机网络.html';">计算机网络</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <h1>
<a id="user-content-如何实现多任务" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何实现多任务？</h1>
<p>有一种特殊的中断叫<strong>时钟中断</strong>，操作系统会借助此中断的中断处理程序，抢夺回CPU资源，然后依据自己的算法，调度系统资源，从而实现多任务处理。</p>
<h1>
<a id="user-content-多核cpu" class="anchor" href="#%E5%A4%9A%E6%A0%B8cpu" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>多核CPU</h1>
<blockquote>
<p>任务调度、中断处理、同步互斥
对于多核CPU，优化操作系统任务调度算法是保证效率的关键。一般任务调度算法有全局队列调度和局部队列调度。前者是指操作系统维护一个全局的任务等待队列，当系统中有一个CPU核心空闲时，操作系统就从全局任务等待队列中选取就绪任务开始在此核心上执行。
这种方法的优点是CPU核心利用率较高。后者是指操作系统为每个CPU内核维护一个局部的任务等待队列，当系统中有一个CPU内核空闲时，便从该核心的任务等待队列中选取恰当的任务执行，这种方法的优点是任务基本上无需在多个CPU核心间切换，有利于提高CPU核心局部Cache命中率。目前多数多核CPU操作系统采用的是基于全局队列的任务调度算法。
多核的中断处理和单核有很大不同。多核的各处理器之间需要通过中断方式进行通信，所以多个处理器之间的本地中断控制器和负责仲裁各核之间中断分配的全局中断控制器也需要封装在芯片内部。
另外,多核CPU是一个多任务系统。由于不同任务会竞争共享资源，因此需要系统提供同步与互斥机制。而传统的用于单核的解决机制并不能满足多核，需要利用硬件提供的“读－修改－写”的原子操作或其他同步互斥机制来保证。</p>
</blockquote>
<h2>
<a id="user-content-java线程与操作系统线程进程关系" class="anchor" href="#java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Java线程与操作系统线程/进程关系</h2>
<p>一对一，多对一，多对多.但注意这里是操作系统封装的线程/进程功能。</p>

          </div>
      </div>
  </body>
  
  </html>
    