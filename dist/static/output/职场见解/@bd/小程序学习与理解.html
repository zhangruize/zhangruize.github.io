
  <!DOCTYPE html>
  <html>
  
  <head>
      <meta charset="utf-8" />
      <title>
          Zrek's blog
      </title>
      <style>
      li {
        cursor:pointer;
      }
      
      li:hover{
        background-color: #ffffff99;
      }
      
      code{
        background-color: #eee;
        padding:2px;
        display:inline-block;
      }
      
      pre{
        background-color: #eee;
        padding:10px;
        padding-left: 20px;
        padding-right: 20px;
      }
      </style>
  </head>
  
  <body style="background:#f7f7f7;">
      <div style="display:flex;width:100%;">
          <div>Zrek's blog</div>
      </div>
      <div style="display:flex;width:100%;">
          <div id="category" style="display: flex; flex-direction:column;background-color: antiquewhite; padding-right:20px;">
          <ul><li>CI CD<ul><li onclick="location.href='../../CI CD/Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li onclick="location.href='../../CI CD/构建优化.html';">构建优化</li></ul></li><li onclick="location.href='../../FromBD.html';">FromBD</li><li onclick="location.href='../../Github&Gitlab-CI&CD理解.html';">Github&Gitlab-CI&CD理解</li><li>archive<ul></ul></li><li>cs<ul><li>android<ul><li onclick="location.href='../../cs/android/holder.html';">holder</li></ul></li><li>llvm<ul><li onclick="location.href='../../cs/llvm/holder.html';">holder</li></ul></li><li>project<ul><li onclick="location.href='../../cs/project/holder.html';">holder</li></ul></li><li>system<ul><li onclick="location.href='../../cs/system/holder.html';">holder</li></ul></li></ul></li><li>java jvm android<ul><li onclick="location.href='../../java jvm android/Activity启动模式理解.html';">Activity启动模式理解</li><li onclick="location.href='../../java jvm android/ConcurrentHashMap理解.html';">ConcurrentHashMap理解</li><li onclick="location.href='../../java jvm android/Dex文件理解.html';">Dex文件理解</li><li onclick="location.href='../../java jvm android/Glide理解.html';">Glide理解</li><li onclick="location.href='../../java jvm android/HashMap理解.html';">HashMap理解</li><li onclick="location.href='../../java jvm android/JVM内存模型.html';">JVM内存模型</li><li onclick="location.href='../../java jvm android/Java内存模型(JMM).html';">Java内存模型(JMM)</li><li onclick="location.href='../../java jvm android/Java动态代码生成方案理解.html';">Java动态代码生成方案理解</li><li onclick="location.href='../../java jvm android/Java并发概述.html';">Java并发概述</li><li onclick="location.href='../../java jvm android/LinkedHashMap理解.html';">LinkedHashMap理解</li><li onclick="location.href='../../java jvm android/MMKVl理解.html';">MMKVl理解</li><li onclick="location.href='../../java jvm android/MultiDex理解.html';">MultiDex理解</li><li onclick="location.href='../../java jvm android/React理解.html';">React理解</li><li onclick="location.href='../../java jvm android/RxJava理解.html';">RxJava理解</li><li onclick="location.href='../../java jvm android/TreeMap理解.html';">TreeMap理解</li><li onclick="location.href='../../java jvm android/volatile理解.html';">volatile理解</li><li onclick="location.href='../../java jvm android/手写React Native.html';">手写React Native</li><li onclick="location.href='../../java jvm android/插件化方案理解.html';">插件化方案理解</li><li onclick="location.href='../../java jvm android/热修复方案理解.html';">热修复方案理解</li><li onclick="location.href='../../java jvm android/第三方面试整理.html';">第三方面试整理</li></ul></li><li>jt<ul></ul></li><li>kotlin<ul><li onclick="location.href='../../kotlin/Kotlin语法糖理解.html';">Kotlin语法糖理解</li><li>META-INF<ul></ul></li></ul></li><li onclick="location.href='../../siteCol.html';">siteCol</li><li>thought works<ul><li onclick="location.href='../../thought works/Thought Works.html';">Thought Works</li></ul></li><li>tool<ul></ul></li><li>v2<ul><li onclick="location.href='../../v2/offer checker.html';">offer checker</li><li>pics<ul></ul></li><li onclick="location.href='../../v2/v2.html';">v2</li></ul></li><li onclick="location.href='../../事件流.html';">事件流</li><li>图说<ul></ul></li><li onclick="location.href='../../年终总结.html';">年终总结</li><li>思考与心态<ul><li onclick="location.href='../../思考与心态/2020-11.html';">2020-11</li><li>Plans<ul></ul></li><li onclick="location.href='../../思考与心态/生活探索.html';">生活探索</li><li onclick="location.href='../../思考与心态/还能做点什么.html';">还能做点什么</li></ul></li><li>操作系统<ul><li onclick="location.href='../../操作系统/多任务操作系统.html';">多任务操作系统</li></ul></li><li>测试<ul><li onclick="location.href='../../测试/MockResponse来进行AndroidTest.html';">MockResponse来进行AndroidTest</li><li onclick="location.href='../../测试/内存泄漏测试.html';">内存泄漏测试</li></ul></li><li>算法<ul><li onclick="location.href='../../算法/算法整理.html';">算法整理</li></ul></li><li>网络<ul><li onclick="location.href='../../网络/计算机网络.html';">计算机网络</li></ul></li><li>职场见解<ul><li onclick="location.href='../../职场见解/ 外部风险管理.html';"> 外部风险管理</li><li>@bd<ul><li onclick="location.href='../../职场见解/@bd/小程序学习与理解.html';">小程序学习与理解</li><li onclick="location.href='../../职场见解/@bd/感受与反思.html';">感受与反思</li></ul></li><li onclick="location.href='../../职场见解/专注过程与专注结果.html';">专注过程与专注结果</li><li onclick="location.href='../../职场见解/为什么研发的话语权这么低.html';">为什么研发的话语权这么低</li><li onclick="location.href='../../职场见解/风险管理与开发流程.html';">风险管理与开发流程</li></ul></li><li onclick="location.href='../../补码运算.html';">补码运算</li></ul>
          </div>
          <div id="reader" style="display: flex; flex-direction:column;flex-grow: 1; padding:20px">
          <p>小程序sdk初始化</p>
<ul>
<li>AppbrandContext.init</li>
</ul>
<p>小程序宿主依赖实现与 可选拓展实现</p>
<ul>
<li>HostDependManager.doXxx  = getHostEssentialDepend().doXxx or hostOptionDependRegister.getXxxDepend().doXxx
使用@Provider, @Inject依赖注入关联实现。(panga gradle plugin)
<ul>
<li>HostOptionCallHandlerDepend
宿主用于创建sync/async的跨进程数据处理功能（列表）。
ProcessCallControlBridge 负责暴露跨进程通讯功能
ProcessConstant.CallHostProcessType / CallMiniAppProcessType / CallDataKey 常量取值</li>
</ul>
</li>
</ul>
<p>小程序Application与服务获取</p>
<ul>
<li>AppbrandApplicationImpl.getService</li>
</ul>
<p>小程序监控
AppbrandMonitor
宿主可以选择实现SdkMonitorDepend（如依赖com.bytedance.frameworks.core:sdk_monitor实现)
若宿主未按上述实现，则会通过IPC以DataHandler发送</p>
<p>小程序进程管理（预加载，复用，状态管理，信息）
AppProcessManager
ProcessInfo
ServiceClass
MiniProcessMonitor(onAlive, onDied)</p>
<p>跨进程通信
host(HostCrossProcessCallService(ihost, 反射实例miniApp包的AppbrandHostProcessImpl))
&lt;-&gt;
miniapp(MiniAppService(0-4 placeholder)&lt;- MiniappHostService)
数据类：CrossProcessCallEntity（callIdentify, callerIdentiy, CrossProcessDataEntity(call data, extra data))
交互统筹：ProcessCallControl(call sync/async, hadnle sync/async 根据callEntity判断h/m2h/m再分发给下面统筹类)
调起类：统筹CrossProcessActionCaller
2host ServiceBindManager
2miniApp MiniProcessMonitor
处理类：统筹CrossProcessCallHandler
2host(async,sync) 先内部检查处理 InnerHostProcessCallHandler，再外部HostDepend-&gt;DataHandler处理
2miniapp(async) 先内部检查处理 InnerMiniAppProcessCallHandler，再外部HostDepend-&gt;DataHandler处理
是最终service的实现
IpcCallback同理</p>
<p>JS基础库管理
BaseBundleManager / BaseBundleFileManager （BaseBundle压缩包工具方法）
BaseBundleHandler有很多子类负责不同的BaseBundle处理功能</p>
<p>offline.zip
config.json</p>
<p>宿主打开小程序(@HostProcess)</p>
<ul>
<li>
<p>AppbrandSupport (ihost, 反射实例化miniapp的AppbrandOpenImpl)
AppbrandOpenImpl(miniapp).openAppbrand
Bundle launchExtraBundle
DisableState (AppbrandConstants.getBundleManager().checkMiniAppDisableState)
AppInfoEntity = AppInfoManager.generateInitAppInfo(scheme)
openMiniAppActivity
LaunchInfo()(processInfo, flag, activityclass, serviceclass) = AppProcessManager.getLaunchClass(...)
doOnMainProcessBeforeColdLaunch or startMiniAppWithSnapshotIfHave
(@workThread)
AppProcessManager.startMiniProcessMonitor
MiniProcessMonitor#startMonitorMiniAppProcess()
context(MainProcess).bindService(Intent(processInfo.preloadServiceClass), connection#onConnected: host2MiniAppBinder)
(@MiniappHostService @MiniAppProcess)
onCreate:
getPreloadManager().preloadWebViewOnProcessInit()
onBind:
checkPermission
ServiceBindManager.getInstance().bindHostService();
context(MiniAppProcess).bindService(Intent(HostCrossProcessCallService(ihost)), connection: miniApp2hostBinder)
(@HostCrossProcessCallService(ihost) @HostProcess) onBind:
反射实例化miniApp: MiniApp2HostBinderStub: sync/async Call -&gt; ProcessCallControlBridge#handleSync/AsyncCall (具体实现ProcessCallControl)
Host2MiniAppBinderStub: asyncCallMiniProcess -&gt; ProcessCallControlBridge#handleAsyncCall (具体实现ProcessCallControl)
InnerMiniAppProcessBridge.prepareLaunch() -&gt; ProcessCallBridge.callMiniAppProcessAsync (具体实现ProcessCallControl)
(@MiniAppProcess @InnerMiniAppProcessCallHandler) handleAsyncCall:
prepareLaunch
AppbrandApplicationImpl.getService(LaunchScheduler.class).startLaunch(AppInfoEntity, scheme, vdom)
prefetch?
routeEventCtrl
subLaunchScheduler(TMA/TMGLaunchScheduler):
JsRuntimeManager.initTMARuntime(第一次会new JsTMARuntime)
TTAppbrandPresenter.requestAppInfo
AppInfoManager.startRequestAppInfo
(@ExcutorThread)
requestAppInfo
requestType is (normal or async)
AppInfoHolder.fetchLocal -..-&gt;UpdateAppManager.getUpdateAppInfo
failed:
PreConnectCDNManager.preConnectCDN
AppInfoRequestResult = anyOf (AppInfoHolder, blockGetAppInfo)
else is preload
AppInfoRequestResult = AppInfoRequester.request()
AppInfoHelper.parseAppInfo(AppInfoRequestResult.lastRecord) succeed:
saveMetaData
UpdateAppManager.saveUpdateAppInfo
failed: InnerEventHelper
requestAppInfoOnSuccess
解密appInfo字段，校验有效性 callListener oneOf (onAppInfoInvalid, requestAppInfoSuccess, requestAppInfoFail)
listener.requestAppInfoSuccess
LaunchScheduler.requestAppInfoSuccess
AppInfoManager.updateAppInfoAfterRequest
AppbrandApplicationImpl.setAppInfo(appInfo);
DebugManager.openDebug(callback)
remoteDebug? openRemoteWsClient(debugHandler) // todo
else callback.complete()
getService(JsRuntimeManager.class).getCurrentRuntime.executeInJsThread (ctx)-&gt;ctx.eval(metaReady())
mPresenter.downloadInstallMiniApp
StreamDownloadManager.startStreamDownload(listener)
// TmaPkgFileDecoder
-..-&gt;listener.onInstallSuccess -&gt; @workThread LaunchScheduler.onInstallSuccess
HostDependManager.getInst().createBlockLoadingCallback().blockLoading
app.getLifeCycleManager().notifyMiniAppInstallSuccess()
PreTTRequestManager.saveAndStartPrefetch(appContext, appConfig, appInfo.appId, schema);
NetUtil.registerListener();
TMALaunchScheduler.onMiniAppInstallSuccess
getService(PageRouter).setup
AppbrandViewWindowRoot#setupLaunch
AppbrandHomePageViewWindow#prepareLaunch
getService(PreloadManager.class).takeFirstPage
getService(JsRuntimeManager).getCurrentRuntime().loadMainJs(callback)
(executeInJsThread @jsThread) (ctx)-&gt;
ctx.eval("loadScript('app-service.js')")
callback#afterEval
LaunchScheduler.onJsCoreReady()
mApp.getRouteEventCtrl().onJsCoreReady()
ReenterGuideHelper.preload()
postAtViewReady -&gt; mRealView.miniAppInstallSuccess()
SynHistoryManager.getInstance().addToRecentApps
NetDnsResolver.getInst().preResolveInetAddressFromHttpDns
InnerHostProcessBridge.updateJumpList(appInfo.appId, appInfo.isGame(), appInfo.isSpecial());
if need prefetch:
AppInfoRequester.request()
InnerMiniAppProcessBridge.sendPrefetchedAppInfo (@MiniAppProcess --...--&gt; AppInfoHolder.appInfoAvailable(appInfo))
startActivityInMainThread
@runOnUiThread
startMiniAppActivity
HostDependManager.getInst().startMiniAppActivity
@MiniAppProcess MiniappHostBase(extends BaseActivity)
onCreate
AppbrandContext.setCurrentActivity
mActivityProxy = createRealActivity = new TTAppbrandTabUI(extends BaseActivityProxy)
TTAppbrandTabUI#beforeOnCreate
TTAppbrandTabUI#onCreate
mActivity.setContentView( anyOf(getService(PreloadManager.class).getPreloadedLoadingView, R.layout.microapp_m_activity_ttappbrand))
root = getService(PageRouter.class).getViewWindowRoot() (理论上每个miniAppPricess就一个AppBrandViewWindowRoot，被PageRouter持有)
root.bindActivity(仅赋值), root.getAppbrandHomePage().设置侧滑消失监听，触发退出
// todo
initLoadingView
getLaunchScheduler().startListenLaunchStatus(this)  -&gt; updateProgressTv (HostDependManager.getMiniAppLifeCycleInstance().onLoading(p))
mApp.setActivityLife(this)
屏幕方向设置
TTAppbrandTabUI#afterCreate -&gt; BaseActivityProxy#afterCreate
getService(LaunchScheduler.class).bindView(this)
mPendingRunnableList 遍历，run, notifyLock, 唤醒之前waitForViewBound阻塞的</p>
<pre><code>          AppbrandConstants.getProcessManager().preloadEmptyProcessDelay
</code></pre>
</li>
</ul>
<p>AppInfoHolder
AppInfo
preload 本地缓存</p>
<p>CDNPreConnect</p>
<p>StreamDownloader</p>
<p>JsTMA/TMGRuntime (extends JSRuntime)
构造时候会调用start()
JSRuntime#start()
维护两个thread &amp; handler并启动: jsThread(JSRunLoop) &amp; jsHandler, workThread(HandlerThread) &amp; workHandler
JSRunLoop启动 -&gt; JsTMARuntime.run  (注意，在JsThread中)
初始化js全局变量，DebugManager(helium开启debug),
setupLoader -&gt; StreamDownloadManager.onLocalPackageFileReady -&gt; TTAppLoader(helum).load()
loadJsSdk
JsBridge@Jscore方法注入到ttJSCore(js环境全局对象),
loadJsCoreFile 加载基础库, 运行pendingScopeCallback</p>
<p>AppbrandViewWindowRoot extends ViewWindowRoot
init: mHomePage = new AppBrandHomePageViewWindow
mViewWindowList
showViewWindow(mHomePage)
v == topView return
v.bringToFront(if v.root == this &amp; parent!=null), topView?.doPause, v.doResume
else v.doOnCreate(this)(ViewWindow.root = this), addToList, container.addView, topView?.doPause, v.doResume</p>
<p>ViewWindowRoot
init: container = new ViewWindowContainer()
ViewWindowManager.regAsViewWindowContainer(this)</p>
<p>ViewWindow extends ViewWindowDragRightLayout
AppBrandViewWindowBase
AppbrandSinglePageViewWindow
AppbrandHomePageViewWindow
init:
addView(mContentView(=RelativeLayout))
mContentView.addView(mPageContainer(=FrameLayout))</p>
<p>预加载view, loadingview, 类, Page
PreloadManager
getPreLoadedLoadingView, getPreloadedView</p>
<p>LaunchProgress
handler(MainLooper).handleMessage WHAT_TICK -&gt; 循环sendDelay(WHAT_TICK, TICK_INTERVAL)直到stop, listener.onProgressChanged
progress自递增到当前status进度上限，不同status对应的progress上限设置见ILaunchStatus</p>
<p>PerformanceService
mMonitorThread(HandlerThreadUtil.getBackgroundHandlerThread())
MonitorHandler 维护一个List tasks，每隔一定时间运行里面所有任务(CpuMonitorTask, MemoryMonitorTask, FpsMonitorTask, MonitorInfoPackTask)</p>
<p>JSRuntime:
loadJsSdk -&gt; load tma-core.js</p>
<pre><code>onMiniAppInstallSuccess: load main js(app-service.js ) require app.js (in pkg)
</code></pre>
<p>NativeNestWebViewLoadBase:
load template <a href="https://tmaservice.developer.toutiao.com/page-frame.html" rel="nofollow">https://tmaservice.developer.toutiao.com/page-frame.html</a>   intercept -&gt; page-frame.html(in <strong>dev</strong>.zip)  require(webview.js in <strong>dev</strong>.zip)   (can be preload)
load page frame: webView.eval("ttJSBridge.subscribeHandler('onPreloadPageFrame');true")
"ttJSBridge.subscribeHandler('onLoadPageFrame',{path: '" + mPathFramePlaceHolder + "'})"  (可能开始加载pkg-&gt;page-frame.js)</p>
<p>有大概3种api到实现的分发方式：</p>
<ol>
<li>ApiServiceInterface 处理</li>
<li>@jscore 判断event处理，</li>
<li>asyncJsInvoke -&gt; jsMsgHandler -&gt; MSG_API_EVENT msg -&gt; handleMessage</li>
</ol>
<p>video 什么时候走native component  什么时候不走component，直接webview渲染</p>
<p>todo:</p>
<ol>
<li>音频视频加密播放验证、等待前端新字段key名确认，QA注意修复了快速离开页面视频没有暂停的问题。
1.1 视频播放出错时，是否发送错误callback</li>
<li>什么时候bugfix合入alpha, 什么时候合入上个版本的bugfix，小版本维护到何时</li>
<li>基础库动画发现问题沟通。</li>
<li>了解mira</li>
<li>跑ui自动化，了解shoots</li>
</ol>
<p>分支合入管理</p>
<ol>
<li>
<p>研发开启自己的feature分支，开发自测。</p>
</li>
<li>
<p>在bytebus打自己分支的包，升级出基线+特定后缀的新sdk版本。</p>
</li>
<li>
<p>根据需要（应该是大部分情况都需要）在AppbrandTest开启新的分支，更改依赖的小程序版本为刚才的特定后缀新版本。打出appbrandtest新包。提供给测试验证功能。</p>
</li>
<li>
<p>测试验收通过，出验收报告。</p>
</li>
<li>
<p>有验收报告的需求可以进行合入。合入时间是周一。（是由BM负责从各feature分支合入到alpha还是各自feature研发负责合入到alpha？）</p>
</li>
<li>
<p>SDK BM进行打包流程 最终把alpha合入到beta。</p>
</li>
<li>
<p>若此次发版需要bugfix，那是需要合入到beta还是alpha?  以及为何会有更早的版本需要bugfix，是因为该版本线上占比较大原因吗？且因为当前beta分支是新版本内容，老版本的后期bugfix是需要单独从beta拉取分支修复吗？
这里老版本的bugfix的合入时间点是怎样的呢？流程是怎样的呢？</p>
</li>
<li>
<p>基础库会在合入的时候由bm统一更新。</p>
</li>
</ol>
<p>js基础库：
JSCore方面：
(java)JsBridge
ttJSBridge.subscribeHandler -&gt; event prefix
is host_event_ -&gt; hostEventMap,
is custom_event_ -&gt; customEventMap,
else -&gt; eventMap</p>
<pre><code>(js)
lib/bridge.js # subscribe -&gt; customEvent map中添加event 2 func 的映射
            # _addHostListener -&gt; 添加 hostEventMap 映射，同上
            # _on -&gt; 添加eventMap映射。

subscribe:
    invokeAppServiceMethod
        when(event.type)
            is bridge -&gt; invoke -&gt; _beforeInvoke -&gt; _invoke -&gt; ttJSCore['call'] or ttJSCore['invoke']
            is sdk -&gt; 
                when(event.name) is request, openModalWebview, closeModalWebview, getAppInfo, getHostInfo
                else -&gt; tt['name'] (见tt[fnc]= xx, core.js, index.js)
            is jssdk
                (postMessage, navigateTo, redirectTo, switchTab, reLaunch, navigateBack, getPhoneNumber, login) @web-view-sdk.js
            is pay-jssdk
    WEBVIEW_ERROR_MSG
        errorReport
    reportTimelinePoints
    addTimingDots
    setPerformance
</code></pre>
<p>webBridge publish(event) -&gt; java ... JsCoreUtils.sendMsgToJsCore -&gt; jsCore subscribe(event)/on(event)/addListener(event)
jsCore publish(event) -&gt; java ... WebView.evaluate -&gt; webView subscribe(event)...</p>
<p>mini-app:
page-frame.js
h(tagName, props, children...) -&gt; VirtualNode(tagName, props, childNodes, key(from props)) 注意，ide生成的render函数通过括号机制最终满足了从叶子节点开始生成VirtualNode到根节点。</p>
<pre><code>    tree-context.js -&gt; createTreeWithContext
</code></pre>
<p>renderer.js
patchRenderer</p>
<p>vdom.cjs.js
h
createElement
renderVNode
applyProperties 绑定属性到node上
applyEvent
addListener (callback -&gt; tt.publishPageEvent
-&gt; webvie/core/bridge.js#publish -&gt; ttJSBridge.publish)
-&gt; (java) webbridge # publish (@javascript interface)
jsObject.callMethod('ttJSBridge.subscribeHandler')</p>
<p>page.js
page2.js
Page
setData
updateData -&gt; clone (k,v) from newData to this.data
queueStateChanges -..-&gt; @queue-update.js # applyState -&gt; syncData
invokeWebviewMethod(name: 'appDataChange'...)
or
invokeWebviewMethod(name: 'componentDataChange'...)
publish('invokeWebviewMethod') -&gt; ttJSBridge.publish
-&gt; (java) jsbridge # publish (@jscore, jscontext setmethod)
NestWebview # evaluateJs('ttJSBridge.subsribeHandler')</p>
<p>service-invoke-webview-method.js
service-invoke-appservice-method.js
service-invoke-gameservice-method.js
invoke-appservice-method.js (from webview)</p>
<p>渲染流程</p>
<p>navigateTo / SwitchTab</p>
<p>SinglePage(from preload or new).navigateTo
RouteEventCtrl
js
updateAppDataState
publish 'onAppDataChange'(此change主要携带参数是pages, 以及路由情况（上个页面，现在的页面，打开方式等等）)
web-service: save 等待后面内容，才开始渲染
nestWebView(of this page) # continue preload if need : page-frame.js(from basebundle) -&gt; xx.js, webview.js
nestWebView load pages/<strong>INDEX_PLACEHOLDER</strong>-frame.js -&gt;
load renderFunc of the page, set to window.<strong>generateFunc</strong>
dispatch page frame event
listener -&gt; (@webview)
renderPage
分3种情况的render，根据appDataChange的参数情况。
syncVdom -&gt; vdomChangeEvent -&gt; jsCore
(JS需要最新的vdom从而支持一些api如selectElements等功能。)</p>
<p>input需求：
当前是无焦点webview有焦点native方式，API：
当获取焦点展示键盘时： (webBrdige#invoke)showKeyboard<br>
当输入内容时：sendEventToJsCore("onKeyboradValueChange")(jsBrdige#publish)custom_event_setKeyboardValue</p>
<p>api:</p>
<p>component:
webview#invoke
api(like insertXxx, updateXxx, removeXxx)
(dispatch to XxxHandler)
Most of them will use NativeViewManager#addView, getView, updateView...</p>
<p>当前对inputComponent专门使用了非同层渲染的absolute Layout。也就是没有使用同层渲染。
手动使input使用同层渲染方式时，可能是因为基础库还没有处理，没有看到webview挖孔，也因此没看到native组件。</p>
<p>todo:了解当前的技术方案文档，熟悉之前准备的技术方案。</p>
<p>dom响应事件：
Tap:
webview: publish some event like custome_event_onTapSomeButton
JSC: receive, run bind event method, if set data was called, will publish appDataChanged
webview: receive appDataChange, (may update vdom), if vdom updated, then publish vdom_changed
JSC: receive, sync vdom data.</p>

          </div>
      </div>
  </body>
  
  </html>
    